###############################################################################
# This file is part of metalibm (https://github.com/kalray/metalibm)
###############################################################################
# MIT License
#
# Copyright (c) 2018 Kalray
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
###############################################################################
# last-modified:    Mar  7th, 2018
# Author(s): Nicolas Brunie <nbrunie@kalray.eu>
###############################################################################
""" meta-function describing a wrapper to benchmark external functions, i.e.
    functions not generated by metalibm """
import sollya

from metalibm_core.core.ml_function import ML_FunctionBasis

from metalibm_core.core.ml_operations import (
    Variable, FunctionObject, Statement, Return)
from metalibm_core.core.ml_formats import ML_Binary32
from metalibm_core.core.precisions import ML_Faithful
from metalibm_core.core.ml_vectorizer import vectorize_format

from metalibm_core.code_generation.generic_processor import GenericProcessor
from metalibm_core.code_generation.generator_utility import FunctionOperator
from metalibm_core.code_generation.code_function import CodeFunction, FunctionGroup
from metalibm_core.code_generation.generator_utility import LibraryDependency

from metalibm_core.utility.ml_template import (
    MultiAryArgTemplate, DefaultMultiAryArgTemplate)
from metalibm_core.utility.log_report  import Log

def atan2_emulate(vy, vx):
    if vx > 0:
        return sollya.atan(vy / vx)
    if vy < 0:
        # vy / vx > 0
        return -sollya.pi + sollya.atan(vy / vx)
    # vy > 0, vy / vx < 0
    return sollya.pi + sollya.atan(vy / vx)


class ML_ExternalBench(ML_FunctionBasis):
    """ Implementation of external bench function wrapper """
    function_name = "ml_external_bench"
    def __init__(self, args=DefaultMultiAryArgTemplate):
        # initializing base class
        ML_FunctionBasis.__init__(self, args)
        # initializing specific properties
        self.headers = args.headers
        self.libraries = args.libraries
        self.extra_src_files = args.extra_src_files
        self.bench_function_name = args.bench_function_name
        self.emulate = args.emulate
        self.arity = args.arity
        self.function_input_vector_size = args.function_input_vector_size
        if len(self.auto_test_range) != self.arity:
            self.auto_test_range = [self.auto_test_range[0]] * self.arity
        if len(self.bench_test_range) != self.arity:
            self.bench_test_range = [self.bench_test_range[0]] * self.arity

    @staticmethod
    def get_default_args(**kw):
        """ Return a structure containing the arguments for ML_ExternalBench
            builtin from a default argument mapping overloaded with @p kw """
        default_args_exp = {
            "output_file": "bench.c",
            "function_name": "external_bench_wrapper",
            "extra_src_files": [],
            "headers": [],
            "libraries": [],
            "precision": ML_Binary32,
            "accuracy": ML_Faithful,
            "function_input_vector_size": 1,
            "target": GenericProcessor.get_target_instance()
        }
        default_args_exp.update(kw)
        return DefaultMultiAryArgTemplate(**default_args_exp)

    def generate_function_object(self, output_format, arg_format_list):
        # explicitly building FunctionOperator and FunctionObject to add
        # requested header list
        external_function_op = FunctionOperator(self.bench_function_name,
                                                arity=self.arity,
                                                output_precision=output_format,
                                                require_header=self.headers,
                                                require_deps=self.libraries)
        external_function = FunctionObject(self.bench_function_name,
                                           arg_format_list,
                                           output_format,
                                           external_function_op)

        return external_function, external_function_op

    def generate_scheme(self):
        assert self.get_vector_size() > 1
        output_format = self.get_output_precision()

        arg_list = tuple(self.implementation.add_input_variable("x_%d" % index, input_format) for index, input_format in enumerate(self.get_input_precisions()))

        external_function, external_function_op = self.generate_function_object(output_format, list(self.get_input_precisions()))

        scheme = Statement(Return(external_function(*arg_list)))
        return scheme


    def generate_function_list(self):
        Log.report(Log.Verbose,
                   "generating external bench for function {} with vector-size {}/{}".format(self.bench_function_name, self.vector_size, self.function_input_vector_size))
        if self.function_input_vector_size == 1 and self.get_vector_size() > 1:
            # relying on auto vectorization
            return ML_FunctionBasis.generate_function_list(self)
        if self.function_input_vector_size > 1:
            output_format = vectorize_format(self.get_output_precision(), self.function_input_vector_size)
            arg_format_list = [vectorize_format(arg_format, self.function_input_vector_size) for arg_format in self.get_input_precisions()]
        else:
            output_format = self.get_output_precision()
            arg_format_list = list(self.get_input_precisions())

        external_function, external_function_op = self.generate_function_object(output_format, arg_format_list)

        benched_function = CodeFunction(self.bench_function_name,
                                        output_format=output_format,
                                        external=True,
                                        vector_size=self.function_input_vector_size,
                                        function_object=external_function,
                                        function_operator=external_function_op)

        # need to overwrite self.implementation as it is used to determine
        # if vectorization is required in ml_function
        self.implementation = benched_function
        for arg_format in arg_format_list:
            benched_function.register_new_input_variable(Variable("", precision=arg_format))
        return FunctionGroup([benched_function])

    def get_extra_build_opts(self):
        return self.extra_src_files

    def numeric_emulate(self, *args):
        return self.emulate(*args)

def add_generic_cmd_args(arg_template):
    """ register the default list of command line arguments for
        ML_ExternalBench """
    arg_template.get_parser().add_argument(
        "--function", dest="bench_function_name", default="expf",
        action="store", type=str, help="name of the function to be benched")
    arg_template.get_parser().add_argument(
        "--headers", dest="headers", default=[], action="store",
        type=lambda s: s.split(","),
        help="comma separated list of required headers")
    arg_template.get_parser().add_argument(
        "--extra-src-files", dest="extra_src_files", default=[], action="store",
        type=lambda s: s.split(","),
        help="comma separated list of required libraries")
    arg_template.get_parser().add_argument(
        "--function-input-vector-size", default=1, action="store",
        type=int,
        help="number of elements in function input vector (1 for scalar)")
    arg_template.get_parser().add_argument(
        "--libraries", dest="libraries", default=[], action="store",
        type=lambda s: [LibraryDependency(h,l) for h,l in [v.split(':') for v in s.split(",")]],
        help="comma separated list of required libraries")

    def local_eval(s):
        return eval(s)
    arg_template.get_parser().add_argument(
        "--emulate", dest="emulate", default=lambda x: x, action="store",
        type=local_eval, help="function numeric emulation")

if __name__ == "__main__":
    # auto-test
    arg_template = MultiAryArgTemplate(default_arg=ML_ExternalBench.get_default_args())

    add_generic_cmd_args(arg_template)

    # argument extraction
    args = arg_template.arg_extraction()
    ext_bench = ML_ExternalBench(args)
    ext_bench.gen_implementation()
